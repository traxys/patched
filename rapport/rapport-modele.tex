\documentclass[a4paper,10pt,french]{article}
\newcounter{question}%[section]
\newcounter{subquestion}%[section]
\newcommand{\question}{%
  \setcounter{subquestion}{0}
  \refstepcounter{question}%
  \paragraph{Question \thequestion}%
}

% Préambule; packages qui peuvent être utiles
   \RequirePackage[T1]{fontenc}        %
   \RequirePackage{babel,indentfirst}  % Pour les césures correctes,
                                       % et pour indenter au début de chaque paragraphe
   \RequirePackage[utf8]{inputenc}   % Pour pouvoir utiliser directement les accents
                                     % et autres caractères français
   \RequirePackage{lmodern,tgpagella} % Police de caractères
   \textwidth 17cm \textheight 25cm \oddsidemargin -0.24cm % Définition taille de la page
   \evensidemargin -1.24cm \topskip 0cm \headheight -1.5cm % Définition des marges
   \RequirePackage{latexsym}                  % Symboles
   \RequirePackage{amsmath}                   % Symboles mathématiques
   \RequirePackage{tikz}   % Pour faire des schémas
   \RequirePackage{graphicx} % Pour inclure des images
   \RequirePackage{listings} % pour mettre des listings
% Fin Préambule; package qui peuvent être utiles

\title{Rapport de TP 4MMAOD : Patch optimal entre deux fichiers}
\author{
	BOYER Quentin (groupe étudiant$_1$)
}

\begin{document}

\maketitle

\section{Graphe de dépendances (1 point)}
{\em Dessinez le graphe de dépendances des appels.}

{L'algorithme est alors de trouver le plus court chemin depuis un point $(i,j) tq i=0 et/ou j=0$. Cela donne donc en fonction du chemin le patch optimal}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Principe de notre  programme (1 point)}
{
	Pour pouvoir trouver le plus court chemin je commence par creer une liste de tout les chemins au depart d'un des bords avec $i=0$ ou $j=0$. Ensuite on fait un tas avec ces chemins. A chaque iteration suivante on prends le chemin le plus court, on l'enleve du tas. Grace a ce chemin on produit trois chemin en incrementant $i$, $j$ puis $i$ et $j$.
	Si un chemin $c1$ arrive sur une case sur laquelle un autre chemin est deja passe, on sait par notre invariant qu'il existe un autre moyen d'arriver a ce point, et qu'il est plus court. On peut donc supprimer $c1$, puisque il sera pire que le chemin qui est deja passe par la.
	Sinon on ajoute le chemin dans notre tas

	On s'arrete des que le plus court chemin arrive sur la case $(m,n)$. On a alors trouve le plus court chemin pour arriver au patch optimal
	
	De plus pour calculer les couts on stock non pas un tableau des lignes mais un tableau qui donne l'indice de la fin de la ligne $i$, cela permet ainsi d'avoir un cout faible pour trouver la longeure d'une ligne
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Analyse du coût théorique (3 points)}
%{\em Donner ici l'analyse du coût théorique de votre programme en fonction des nombres $n_1$ et $n_2$ de lignes
%et $c_1$ et $c_2$ de caractères des deux fichiers en entrée.
%Pour chaque coût, donner la formule qui le caractérise (en justifiant brièvement pourquoi cette formule correspond à votre programme),
%puis l'ordre du coût en fonction de $n_1, n_2, c_1, c_2$ en notation $\Theta$ de préférence, sinon $O$.}
{
	On commence par calculer la liste des indices de fin de ligne, ca coute $m+n$ dans tout les cas.
}

  \subsection{Nombre  d'opérations en pire cas\,: }
    \paragraph{Justification\,: }
	Dans le pire cas il faut calculer tout les chemins possibles, c'est a dire passer par chaque case exactement une fois, cela fait donc $m\times n$ iterations. A chaque iteration on produit environ 1 chemin, puisque si rentre en collision avec les autres chemins, au total on est donc en $\Theta(m\times n)$
  \subsection{Place mémoire requise\,: }
    \paragraph{Justification\,: }
	Dans chaque case on doit stocker de quelle cases viens t'on, pour pouvoir refaire le chemin dans le sens inverse. Cela fait donc dans le pire cas autant de place requise que de chemins, soit $\Theta(m\times n)$.
  \subsection{Nombre de défauts de cache sur le modèle CO\,: }
    \paragraph{Justification\,: }
	Pour les defauts de cache, dans le pire cas a chaque fois qu'on essaye d'acceder a une case elle n'est pas dans le cache, si par exemple les chemins les plus courts sont dans des parties totalement differentes de la grille. Cela coute donc $\Theta(m\times n)$

	\subsection{Quand arrive le pire cas}
{
	Si les fichiers ne sont pas tres differents on va rester majoritairement autour de la diagonale. Cela change donc beacoup la donne, puisque on va faire des defauts de cache que lorsque on a trop avance dans la diagonale, on va calculer et garder en memoire qu'environ la diagonale.

	Si $m\approx n$ on a la diagonale de longeure $m$, cela donne donc un algorithme quasiment lineaire en la taille des fichiers, et $m/L$ defauts de cache environ
}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Compte rendu d'expérimentation (2 points)}
  \subsection{Conditions expérimentaless}
     {\em Décrire les conditions permettant la reproductibilité des mesures: on demande la description
      de la machine et la méthode utilisée pour mesurer le temps.
     }

    \subsubsection{Description synthétique de la machine\,:}
      {\em indiquer ici le  processeur et sa fréquence, la mémoire, le système d'exploitation.
       Préciser aussi si la machine était monopolisée pour un test, ou notamment si
       d'autres processus ou utilisateurs étaient en cours d'exécution.
      }

    \subsubsection{Méthode utilisée pour les mesures de temps\,: }
      {\em préciser ici  comment les mesures de temps ont été effectuées (fonction appelée) et l'unité de temps; en particulier,
       préciser comment les 5 exécutions pour chaque test ont été faites (par exemple si le même test est fait 5 fois de suite, ou si les tests sont alternés entre
       les mesures, ou exécutés en concurrence etc).
      }

  \subsection{Mesures expérimentales}
    {\em Compléter le tableau suivant par les temps d'exécution mesurés pour chacun des 6 benchmarks imposés
              (temps minimum, maximum et moyen sur 5 exécutions)
    }

    \begin{figure}[h]
      \begin{center}
        \begin{tabular}{|l||r||r|r|r||}
          \hline
          \hline
            & coût         & temps     & temps   & temps \\
            & du patch     & min       & max     & moyen \\
          \hline
          \hline
            benchmark\_00 &      &     &     &     \\
          \hline
            benchmark\_01 &      &     &     &     \\
          \hline
            benchmark\_02 &      &     &     &     \\
          \hline
            benchmark\_03 &      &     &     &     \\
          \hline
            benchmark\_04 &      &     &     &     \\
          \hline
          \hline
        \end{tabular}
        \caption{Mesures des temps minimum, maximum et moyen de 5 exécutions pour les benchmarks.}
        \label{table-temps}
      \end{center}
    \end{figure}

\subsection{Analyse des résultats expérimentaux}
{\em Donner  une réponse justifiée  à la question\,:
              les  temps mesurés correspondent ils  à votre analyse théorique (nombre d’opérations et défauts de cache) ?
}

\section{Coût du patch en octet (1 point)}
  {\em Quelle méthode utiliseriez vous pour résoudre le problème si le coût d’un patch était défini comme
sa taille en nombre d’octets (i.e. taille du fichier patch).
On ne demande pas de programme ni d’algorithme, mais juste de préciser le principe de la résolution
choisie (parmi celles vues en cours) ; on précisera soit les équations de base pour la résolution, soit
les modifications à apporter à votre programme s’il peut être adapté à cette fonction de coût.
  }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Bonus : Pourrait-on utiliser une technique de blocking ? (1 point)}
{\em
Si oui, quel serait asymptotiquement le nombre de défauts de
cache avec un cache de taille Z chargé par par lignes de taille L ?
}
\end{document}
%% Fin mise au format
